{"version":3,"file":"tAHCZdDM.js","sources":["../../../node_modules/.pnpm/ufo@1.5.4/node_modules/ufo/dist/index.mjs","../../virtual:nuxt:/home/runner/work/openverse/openverse/frontend/.nuxt/nitro.client.mjs","../../virtual:nuxt:/home/runner/work/openverse/openverse/frontend/.nuxt/paths.mjs"],"sourcesContent":["const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\").replace(SLASH_RE, \"%2F\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  const cleanPath = s0.endsWith(\"/\") ? s0.slice(0, -1) : s0;\n  return (cleanPath || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction joinRelativeURL(..._input) {\n  const JOIN_SEGMENT_SPLIT_RE = /\\/(?!\\/)/;\n  const input = _input.filter(Boolean);\n  const segments = [];\n  let segmentsDepth = 0;\n  for (const i of input) {\n    if (!i || i === \"/\") {\n      continue;\n    }\n    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {\n      if (!s || s === \".\") {\n        continue;\n      }\n      if (s === \"..\") {\n        if (segments.length === 1 && hasProtocol(segments[0])) {\n          continue;\n        }\n        segments.pop();\n        segmentsDepth--;\n        continue;\n      }\n      if (sindex === 1 && segments[segments.length - 1]?.endsWith(\":/\")) {\n        segments[segments.length - 1] += \"/\" + s;\n        continue;\n      }\n      segments.push(s);\n      segmentsDepth++;\n    }\n  }\n  let url = segments.join(\"/\");\n  if (segmentsDepth >= 0) {\n    if (input[0]?.startsWith(\"/\") && !url.startsWith(\"/\")) {\n      url = \"/\" + url;\n    } else if (input[0]?.startsWith(\"./\") && !url.startsWith(\"./\")) {\n      url = \"./\" + url;\n    }\n  } else {\n    url = \"../\".repeat(-1 * segmentsDepth) + url;\n  }\n  if (input[input.length - 1]?.endsWith(\"/\") && !url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  let match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    match = input.match(/^\\/{2,}/);\n  }\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction normalizeURL(input) {\n  const parsed = parseURL(input);\n  parsed.pathname = encodePath(decodePath(parsed.pathname));\n  parsed.hash = encodeHash(decode(parsed.hash));\n  parsed.host = encodeHost(decode(parsed.host));\n  parsed.search = stringifyQuery(parseQuery(parsed.search));\n  return stringifyParsedURL(parsed);\n}\nfunction resolveURL(base = \"\", ...inputs) {\n  if (typeof base !== \"string\") {\n    throw new TypeError(\n      `URL input should be string received ${typeof base} (${base})`\n    );\n  }\n  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));\n  if (filteredInputs.length === 0) {\n    return base;\n  }\n  const url = parseURL(base);\n  for (const inputSegment of filteredInputs) {\n    const urlSegment = parseURL(inputSegment);\n    if (urlSegment.pathname) {\n      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);\n    }\n    if (urlSegment.hash && urlSegment.hash !== \"#\") {\n      url.hash = urlSegment.hash;\n    }\n    if (urlSegment.search && urlSegment.search !== \"?\") {\n      if (url.search && url.search !== \"?\") {\n        const queryString = stringifyQuery({\n          ...parseQuery(url.search),\n          ...parseQuery(urlSegment.search)\n        });\n        url.search = queryString.length > 0 ? \"?\" + queryString : \"\";\n      } else {\n        url.search = urlSegment.search;\n      }\n    }\n  }\n  return stringifyParsedURL(url);\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\nfunction withFragment(input, hash) {\n  if (!hash || hash === \"#\") {\n    return input;\n  }\n  const parsed = parseURL(input);\n  parsed.hash = hash === \"\" ? \"\" : \"#\" + encodeHash(hash);\n  return stringifyParsedURL(parsed);\n}\nfunction withoutFragment(input) {\n  return stringifyParsedURL({ ...parseURL(input), hash: \"\" });\n}\nfunction withoutHost(input) {\n  const parsed = parseURL(input);\n  return (parsed.pathname || \"/\") + parsed.search + parsed.hash;\n}\n\nconst protocolRelative = Symbol.for(\"ufo:protocolRelative\");\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  let [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  if (protocol === \"file:\") {\n    path = path.replace(/\\/(?=[A-Za-z]:)/, \"\");\n  }\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash,\n    [protocolRelative]: !protocol\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || \"\") + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", { strict }) {\n  const { pathname } = parseURL(input);\n  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass $URL {\n  constructor(input = \"\") {\n    __publicField(this, \"protocol\");\n    __publicField(this, \"host\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"pathname\");\n    __publicField(this, \"query\", {});\n    __publicField(this, \"hash\");\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryKey, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, isScriptProtocol, joinRelativeURL, joinURL, normalizeURL, parseAuth, parseFilename, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withFragment, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutFragment, withoutHost, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","export const useRuntimeConfig = () => \nwindow?.__NUXT__?.config || {}","import { joinRelativeURL } from 'ufo'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase\n}\nif (import.meta.client) {\n  globalThis.__buildAssetsURL = buildAssetsURL\n  globalThis.__publicAssetsURL = publicAssetsURL\n}"],"names":["HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","PLUS_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_PIPE_RE","ENC_SPACE_RE","encode","text","encodeQueryValue","input","encodeQueryKey","decode","decodeQueryKey","decodeQueryValue","parseQuery","parametersString","object","parameter","key","value","encodeQueryItem","_value","stringifyQuery","query","k","PROTOCOL_STRICT_REGEX","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","PROTOCOL_SCRIPT_RE","TRAILING_SLASH_RE","JOIN_LEADING_SLASH_RE","hasProtocol","inputString","opts","isScriptProtocol","protocol","hasTrailingSlash","respectQueryAndFragment","withoutTrailingSlash","path","fragment","fragmentIndex","s0","s","withTrailingSlash","hasLeadingSlash","withLeadingSlash","withBase","base","isEmptyURL","_base","joinURL","withoutBase","trimmed","withQuery","parsed","parseURL","mergedQuery","stringifyParsedURL","url","isNonEmptyURL","segment","url2","_segment","joinRelativeURL","_input","JOIN_SEGMENT_SPLIT_RE","segments","segmentsDepth","i","sindex","_a","_b","_c","_d","isEqual","a","b","options","protocolRelative","defaultProto","_specialProtoMatch","_proto","_pathname","parsePath","auth","hostAndPath","host","pathname","search","hash","useRuntimeConfig","appConfig","buildAssetsDir","buildAssetsURL","publicAssetsURL","publicBase"],"mappings":"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","x_google_ignoreList":[0,1,2]}