{"version":3,"file":"D6RkRnWy.js","sources":["../../shared/utils/math.ts"],"sourcesContent":["/**\n * Math utilities\n */\n\nexport type Point = [number, number]\n\n/**\n * Perform linear interpolation to find a value that is fractionally between\n * the low and high limits of the given range.\n *\n * @param low - the lower limit of the range\n * @param high - the upper limit of the range\n * @param frac - fraction controlling position of interpolated number\n * @returns the interpolated number\n */\nexport const lerp = (low: number, high: number, frac: number): number =>\n  low + (high - low) * frac\n\n/**\n * Interpolate twice to solve the Bézier equation for three points P0, P1\n * and P2.\n *\n * @param p0 - point #0\n * @param p1 - point #1\n * @param p2 - point #2\n * @param frac - the fraction at which to solve the Bézier equation\n * @returns a solution to the 3-point Bézier equation\n */\nexport const doubleLerp = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  frac: number\n): Point => [\n  lerp(lerp(p0[0], p1[0], frac), lerp(p1[0], p2[0], frac), frac),\n  lerp(lerp(p0[1], p1[1], frac), lerp(p1[1], p2[1], frac), frac),\n]\n\n/**\n * Find the distance between two points P0 and P1.\n *\n * @param p0 - point #0\n * @param p1 - point #1\n * @returns the distance between the two points\n */\nexport const dist = (p0: Point, p1: Point): number =>\n  Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2))\n\n/**\n * Get the required number of x-coordinates of Bézier points using 4 control\n * points.\n *\n * @param ctrlPts - the array of control points\n * @param pointCount - the number of Bézier points to calculate\n * @returns the list of x-coordinates of Bézier points\n */\nexport const bezier = (ctrlPts: Point[], pointCount: number): number[] => {\n  const bezierPoints = []\n  for (let i = 0; i <= pointCount; i++) {\n    const frac = i / pointCount\n    const a = doubleLerp(ctrlPts[0], ctrlPts[1], ctrlPts[2], frac)\n    const b = doubleLerp(ctrlPts[1], ctrlPts[2], ctrlPts[3], frac)\n    const x = lerp(a[0], b[0], frac)\n    bezierPoints.push(x)\n  }\n  return bezierPoints\n}\n\n/**\n * Shift the given value by the given offset while remaining in the range\n * specified by the params `min` and `max`.\n *\n * @param value - the number to shift\n * @param offset - the amount by which to shift `value`\n * @param min - the lower bound of the limiting range\n * @param max - the upper bound of the limiting range\n */\nexport const cyclicShift = (\n  value: number,\n  offset: number,\n  min: number,\n  max: number\n): number => {\n  return (value + offset + max - min) % (max - min)\n}\n"],"names":["lerp","low","high","frac","doubleLerp","p0","p1","p2","dist","bezier","ctrlPts","pointCount","bezierPoints","i","a","b","x","cyclicShift","value","offset","min","max"],"mappings":"+UAeO,MAAMA,EAAO,CAACC,EAAaC,EAAcC,IAC9CF,GAAOC,EAAOD,GAAOE,EAYVC,EAAa,CACxBC,EACAC,EACAC,EACAJ,IACU,CACVH,EAAKA,EAAKK,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGH,CAAI,EAAGH,EAAKM,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGJ,CAAI,EAAGA,CAAI,EAC7DH,EAAKA,EAAKK,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGH,CAAI,EAAGH,EAAKM,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGJ,CAAI,EAAGA,CAAI,CAC/D,EASaK,EAAO,CAACH,EAAWC,IAC9B,KAAK,KAAK,KAAK,IAAID,EAAG,CAAC,EAAIC,EAAG,CAAC,EAAG,CAAC,EAAI,KAAK,IAAID,EAAG,CAAC,EAAIC,EAAG,CAAC,EAAG,CAAC,CAAC,EAUtDG,EAAS,CAACC,EAAkBC,IAAiC,CACxE,MAAMC,EAAe,CAAC,EACtB,QAASC,EAAI,EAAGA,GAAKF,EAAYE,IAAK,CACpC,MAAMV,EAAOU,EAAIF,EACXG,EAAIV,EAAWM,EAAQ,CAAC,EAAGA,EAAQ,CAAC,EAAGA,EAAQ,CAAC,EAAGP,CAAI,EACvDY,EAAIX,EAAWM,EAAQ,CAAC,EAAGA,EAAQ,CAAC,EAAGA,EAAQ,CAAC,EAAGP,CAAI,EACvDa,EAAIhB,EAAKc,EAAE,CAAC,EAAGC,EAAE,CAAC,EAAGZ,CAAI,EAC/BS,EAAa,KAAKI,CAAC,CAAA,CAEd,OAAAJ,CACT,EAWaK,EAAc,CACzBC,EACAC,EACAC,EACAC,KAEQH,EAAQC,EAASE,EAAMD,IAAQC,EAAMD"}