{"version":3,"file":"CbATagvU.js","sources":["../../../node_modules/.pnpm/nuxt@3.15.1_@parcel+watcher@2.4.1_@types+node@22.8.5_db0@0.1.4_encoding@0.1.13_eslint@9.13.0__p6pp5ym65s56ibxfvk3gng4uxm/node_modules/nuxt/dist/app/components/route-provider.js","../../../node_modules/.pnpm/nuxt@3.15.1_@parcel+watcher@2.4.1_@types+node@22.8.5_db0@0.1.4_encoding@0.1.13_eslint@9.13.0__p6pp5ym65s56ibxfvk3gng4uxm/node_modules/nuxt/dist/pages/runtime/page.js","../../src/pages/search.vue"],"sourcesContent":["import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const RouteProvider = defineComponent({\n  props: {\n    vnode: {\n      type: Object,\n      required: true\n    },\n    route: {\n      type: Object,\n      required: true\n    },\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],\n        enumerable: true\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\n","import { Fragment, Suspense, Transition, defineComponent, h, inject, nextTick, ref, watch } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, toArray, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, slots, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    let previousPageKey;\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtPageUsed = true;\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          const isRenderingNewRouteInOldFork = import.meta.client && haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = import.meta.client && forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (import.meta.client && vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (import.meta.client && vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (import.meta.client && isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          if (!nuxtApp.isHydrating && !hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component) && previousPageKey === key) {\n            nuxtApp.callHook(\"page:loading:end\");\n          }\n          previousPageKey = key;\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            { onAfterLeave: () => {\n              nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n            } }\n          ].filter(Boolean));\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapIf(\n            Transition,\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => nuxtApp.callHook(\"page:loading:end\")).finally(done));\n                }\n              }, {\n                default: () => {\n                  const providerVNode = h(RouteProvider, {\n                    key: key || void 0,\n                    vnode: slots.default ? h(Fragment, void 0, slots.default(routeProps)) : routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  });\n                  if (import.meta.client && keepaliveConfig) {\n                    providerVNode.type.name = routeProps.Component.type.name || routeProps.Component.type.__name || \"RouteProvider\";\n                  }\n                  return providerVNode;\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.map((prop) => ({\n    ...prop,\n    onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n  }));\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\nfunction hasChildrenRoutes(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  return index < newRoute.matched.length - 1;\n}\n","<script setup lang=\"ts\">\nimport {\n  createError,\n  definePageMeta,\n  navigateTo,\n  showError,\n  useAsyncData,\n  useHead,\n  useNuxtApp,\n  useRoute,\n} from \"#imports\"\nimport { computed, ref, watch } from \"vue\"\n\nimport { watchDebounced } from \"@vueuse/core\"\nimport { storeToRefs } from \"pinia\"\n\nimport { ALL_MEDIA } from \"#shared/constants/media\"\nimport { skipToContentTargetId } from \"#shared/constants/window\"\nimport { areQueriesEqual } from \"#shared/utils/search-query-transform\"\nimport { handledClientSide, isRetriable } from \"#shared/utils/errors\"\nimport type { Results } from \"#shared/types/result\"\nimport { searchMiddleware } from \"~/middleware/search\"\nimport { useFeatureFlagStore } from \"~/stores/feature-flag\"\nimport { useMediaStore } from \"~/stores/media\"\nimport { isSearchTypeSupported, useSearchStore } from \"~/stores/search\"\n\nimport VErrorSection from \"~/components/VErrorSection/VErrorSection.vue\"\n\ndefineOptions({\n  name: \"SearchPage\",\n})\n\ndefinePageMeta({\n  layout: \"search-layout\",\n  middleware: searchMiddleware,\n})\n\nconst nuxtApp = useNuxtApp()\n\nconst featureFlagStore = useFeatureFlagStore()\nconst mediaStore = useMediaStore()\nconst searchStore = useSearchStore()\n\nconst route = useRoute()\n\nconst {\n  searchTerm,\n  searchType,\n  apiSearchQueryParams: query,\n} = storeToRefs(searchStore)\n\nconst { fetchState } = storeToRefs(mediaStore)\n\nconst pageTitle = ref(`${searchTerm.value} | Openverse`)\nwatch(searchTerm, () => {\n  pageTitle.value = `${searchTerm.value} | Openverse`\n})\n\nuseHead(() => ({\n  title: pageTitle.value,\n}))\n\nconst searchResults = ref<Results | null>(\n  isSearchTypeSupported(searchType.value)\n    ? ({\n        type: searchType.value,\n        items:\n          searchType.value === ALL_MEDIA\n            ? mediaStore.allMedia\n            : mediaStore.resultItems[searchType.value],\n      } as Results)\n    : null\n)\n\nconst fetchMedia = async (payload: { shouldPersistMedia?: boolean } = {}) => {\n  if (!isSearchTypeSupported(searchType.value)) {\n    return\n  }\n  /**\n   * If the fetch has already started in the middleware,\n   * and there is an error status that will not change if retried, don't re-fetch.\n   */\n  const shouldNotRefetch =\n    fetchState.value.hasStarted &&\n    fetchingError.value !== null &&\n    !isRetriable(fetchingError.value)\n  if (shouldNotRefetch) {\n    return\n  }\n  if (!payload.shouldPersistMedia) {\n    searchResults.value = { type: searchType.value, items: [] }\n  }\n\n  const media = await mediaStore.fetchMedia(payload)\n  searchResults.value = { type: searchType.value, items: media } as Results\n\n  if (fetchingError.value === null || handledClientSide(fetchingError.value)) {\n    return media\n  }\n  return fetchingError.value\n}\n\nconst fetchingError = computed(() => fetchState.value.fetchingError)\nconst isFetching = computed(() => fetchState.value.isFetching)\n\n/**\n * This watcher fires even when the queries are equal. We update the path only\n * when the queries change.\n */\nwatchDebounced(\n  query,\n  (newQuery, oldQuery) => {\n    if (!areQueriesEqual(newQuery, oldQuery)) {\n      navigateTo(searchStore.getSearchPath())\n    }\n  },\n  { debounce: 800, maxWait: 5000 }\n)\n\nconst routeQuery = computed(() => route.query)\nconst routePath = computed(() => route.path)\nconst shouldFetchSensitiveResults = computed(() => {\n  return featureFlagStore.isOn(\"fetch_sensitive\")\n})\n\nconst handleLoadMore = async () => {\n  await fetchMedia({ shouldPersistMedia: true })\n}\n\nawait useAsyncData(\n  \"search\",\n  async () => {\n    if (nuxtApp.isHydrating) {\n      return searchResults.value\n    }\n    /**\n     * By default, Nuxt only scrolls to top when the path changes.\n     * This is a workaround to scroll to top when the query changes.\n     */\n    document.getElementById(\"main-page\")?.scroll(0, 0)\n    const res = await fetchMedia()\n    if (!res || (res && \"requestKind\" in res)) {\n      return showError(res ?? createError(\"No results found\"))\n    }\n    return res\n  },\n  {\n    server: false,\n    lazy: true,\n    watch: [shouldFetchSensitiveResults, routeQuery, routePath],\n  }\n)\n</script>\n\n<template>\n  <div\n    :id=\"skipToContentTargetId\"\n    tabindex=\"-1\"\n    class=\"browse-page flex w-full flex-col px-6 lg:px-10\"\n  >\n    <VErrorSection\n      v-if=\"fetchingError\"\n      :fetching-error=\"fetchingError\"\n      class=\"w-full py-10\"\n    />\n    <div v-else>\n      <NuxtPage\n        :page-key=\"$route.path\"\n        :results=\"searchResults\"\n        :is-fetching=\"isFetching\"\n        :search-term=\"searchTerm\"\n        :handle-load-more=\"handleLoadMore\"\n        data-testid=\"search-results\"\n      />\n    </div>\n  </div>\n</template>\n"],"names":["RouteProvider","defineComponent","props","previousKey","previousRoute","route","key","provide","PageRouteSymbol","shallowReactive","h","__nuxt_component_0","attrs","slots","expose","nuxtApp","useNuxtApp","pageRef","ref","forkRoute","inject","previousPageKey","_layoutMeta","LayoutMetaSymbol","vnode","done","removeErrorHook","useRouter","watch","next","prev","RouterView","routeProps","isRenderingNewRouteInOldFork","haveParentRoutesRendered","hasSameChildren","generateRouteKey","hasChildrenRoutes","hasTransition","defaultPageTransition","transitionProps","_mergeTransitionProps","keepaliveConfig","defaultKeepaliveConfig","_wrapIf","Transition","wrapInKeepAlive","Suspense","nextTick","providerVNode","Fragment","_props","prop","toArray","defu","fork","newRoute","Component","index","m","_a","c","i","_c","_b","featureFlagStore","useFeatureFlagStore","mediaStore","useMediaStore","searchStore","useSearchStore","useRoute","searchTerm","searchType","query","storeToRefs","fetchState","pageTitle","useHead","searchResults","isSearchTypeSupported","ALL_MEDIA","fetchMedia","payload","fetchingError","isRetriable","media","handledClientSide","computed","isFetching","watchDebounced","newQuery","oldQuery","areQueriesEqual","navigateTo","routeQuery","routePath","shouldFetchSensitiveResults","handleLoadMore","__temp","__restore","_withAsyncContext","useAsyncData","res","showError","createError"],"mappings":"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","x_google_ignoreList":[0,1]}