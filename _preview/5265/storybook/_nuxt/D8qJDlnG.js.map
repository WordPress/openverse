{"version":3,"file":"D8qJDlnG.js","sources":["../../src/stores/provider.ts"],"sourcesContent":["import { useNuxtApp } from \"#imports\"\n\nimport { defineStore } from \"pinia\"\n\nimport {\n  ALL_MEDIA,\n  AUDIO,\n  IMAGE,\n  type SupportedMediaType,\n  supportedMediaTypes,\n} from \"#shared/constants/media\"\nimport { capitalCase } from \"#shared/utils/case\"\nimport type { MediaProvider } from \"#shared/types/media-provider\"\nimport type { FetchingError, FetchState } from \"#shared/types/fetch-state\"\n\nexport interface ProviderState {\n  providers: {\n    audio: MediaProvider[]\n    image: MediaProvider[]\n  }\n  fetchState: FetchState\n  sourceNames: {\n    audio: string[]\n    image: string[]\n  }\n}\n\n/**\n * Sorts providers by their source_name property.\n * @param data - initial unordered list of providers\n */\nexport const sortProviders = (data: MediaProvider[]): MediaProvider[] => {\n  if (!data.length || !Array.isArray(data)) {\n    return []\n  }\n  return data.sort((sourceObjectA, sourceObjectB) => {\n    const nameA = sourceObjectA.source_name.toUpperCase()\n    const nameB = sourceObjectB.source_name.toUpperCase()\n    return nameA.localeCompare(nameB)\n  })\n}\n\nexport const useProviderStore = defineStore(\"provider\", {\n  state: (): ProviderState => ({\n    providers: {\n      [AUDIO]: [],\n      [IMAGE]: [],\n    },\n    fetchState: { isFetching: false, fetchingError: null },\n    sourceNames: {\n      [AUDIO]: [],\n      [IMAGE]: [],\n    },\n  }),\n\n  actions: {\n    _endFetching(error?: FetchingError) {\n      this.fetchState.fetchingError = error || null\n      if (error) {\n        this.fetchState.isFinished = true\n      }\n    },\n    _startFetching() {\n      this.fetchState.isFetching = true\n    },\n\n    _updateFetchState(action: \"start\" | \"end\", option?: FetchingError) {\n      if (action === \"start\") {\n        this._startFetching()\n      } else {\n        this._endFetching(option)\n      }\n    },\n\n    _getProvider(providerCode: string, mediaType: SupportedMediaType) {\n      return this.providers[mediaType].find(\n        (p) => p.source_name === providerCode\n      )\n    },\n\n    /**\n     * Returns the display name for provider if available, or capitalizes the given providerCode.\n     *\n     * @param providerCode - the `source_name` property of the provider\n     * @param mediaType - mediaType of the provider\n     */\n    getProviderName(providerCode: string, mediaType: SupportedMediaType) {\n      return (\n        this._getProvider(providerCode, mediaType)?.display_name ||\n        capitalCase(providerCode)\n      )\n    },\n\n    /**\n     * Returns the source URL given the source code and media type.\n     */\n    getSourceUrl(providerCode: string, mediaType: SupportedMediaType) {\n      return this._getProvider(providerCode, mediaType)?.source_url\n    },\n\n    setMediaTypeProviders(\n      mediaType: SupportedMediaType,\n      providers: MediaProvider[]\n    ) {\n      if (!providers.length) {\n        return\n      }\n      this.providers[mediaType] = sortProviders(providers)\n      this.sourceNames[mediaType] = providers.map((p) => p.source_name)\n    },\n\n    async fetchProviders() {\n      this._updateFetchState(\"start\")\n      try {\n        const res =\n          await $fetch<Record<SupportedMediaType, MediaProvider[]>>(\n            `/api/sources/`\n          )\n        if (!res) {\n          throw new Error(\"No sources data returned from the API\")\n        }\n        for (const mediaType of supportedMediaTypes) {\n          this.setMediaTypeProviders(mediaType, res[mediaType])\n        }\n        this._updateFetchState(\"end\")\n      } catch (error: unknown) {\n        const { $processFetchingError } = useNuxtApp()\n        const errorData = $processFetchingError(error, ALL_MEDIA, \"provider\")\n        this._updateFetchState(\"end\", errorData)\n      }\n    },\n\n    /**\n     * Returns true if the given source name exists in the given media type sources list.\n     */\n    isSourceNameValid(\n      mediaType: SupportedMediaType,\n      sourceName: string\n    ): boolean {\n      return this.sourceNames[mediaType].includes(sourceName)\n    },\n  },\n})\n"],"names":["sortProviders","data","sourceObjectA","sourceObjectB","nameA","nameB","useProviderStore","defineStore","AUDIO","IMAGE","error","action","option","providerCode","mediaType","p","_a","capitalCase","providers","res","supportedMediaTypes","$processFetchingError","useNuxtApp","errorData","ALL_MEDIA","sourceName"],"mappings":"4eA+Ba,MAAAA,EAAiBC,GACxB,CAACA,EAAK,QAAU,CAAC,MAAM,QAAQA,CAAI,EAC9B,CAAC,EAEHA,EAAK,KAAK,CAACC,EAAeC,IAAkB,CAC3C,MAAAC,EAAQF,EAAc,YAAY,YAAY,EAC9CG,EAAQF,EAAc,YAAY,YAAY,EAC7C,OAAAC,EAAM,cAAcC,CAAK,CAAA,CACjC,EAGUC,EAAmBC,EAAY,WAAY,CACtD,MAAO,KAAsB,CAC3B,UAAW,CACT,CAACC,CAAK,EAAG,CAAC,EACV,CAACC,CAAK,EAAG,CAAA,CACX,EACA,WAAY,CAAE,WAAY,GAAO,cAAe,IAAK,EACrD,YAAa,CACX,CAACD,CAAK,EAAG,CAAC,EACV,CAACC,CAAK,EAAG,CAAA,CAAC,CACZ,GAGF,QAAS,CACP,aAAaC,EAAuB,CAC7B,KAAA,WAAW,cAAgBA,GAAS,KACrCA,IACF,KAAK,WAAW,WAAa,GAEjC,EACA,gBAAiB,CACf,KAAK,WAAW,WAAa,EAC/B,EAEA,kBAAkBC,EAAyBC,EAAwB,CAC7DD,IAAW,QACb,KAAK,eAAe,EAEpB,KAAK,aAAaC,CAAM,CAE5B,EAEA,aAAaC,EAAsBC,EAA+B,CACzD,OAAA,KAAK,UAAUA,CAAS,EAAE,KAC9BC,GAAMA,EAAE,cAAgBF,CAC3B,CACF,EAQA,gBAAgBA,EAAsBC,EAA+B,OACnE,QACEE,EAAA,KAAK,aAAaH,EAAcC,CAAS,IAAzC,YAAAE,EAA4C,eAC5CC,EAAYJ,CAAY,CAE5B,EAKA,aAAaA,EAAsBC,EAA+B,OAChE,OAAOE,EAAA,KAAK,aAAaH,EAAcC,CAAS,IAAzC,YAAAE,EAA4C,UACrD,EAEA,sBACEF,EACAI,EACA,CACKA,EAAU,SAGf,KAAK,UAAUJ,CAAS,EAAId,EAAckB,CAAS,EAC9C,KAAA,YAAYJ,CAAS,EAAII,EAAU,IAAKH,GAAMA,EAAE,WAAW,EAClE,EAEA,MAAM,gBAAiB,CACrB,KAAK,kBAAkB,OAAO,EAC1B,GAAA,CACF,MAAMI,EACJ,MAAM,OACJ,eACF,EACF,GAAI,CAACA,EACG,MAAA,IAAI,MAAM,uCAAuC,EAEzD,UAAWL,KAAaM,EACtB,KAAK,sBAAsBN,EAAWK,EAAIL,CAAS,CAAC,EAEtD,KAAK,kBAAkB,KAAK,QACrBJ,EAAgB,CACjB,KAAA,CAAE,sBAAAW,CAAsB,EAAIC,EAAW,EACvCC,EAAYF,EAAsBX,EAAOc,EAAW,UAAU,EAC/D,KAAA,kBAAkB,MAAOD,CAAS,CAAA,CAE3C,EAKA,kBACET,EACAW,EACS,CACT,OAAO,KAAK,YAAYX,CAAS,EAAE,SAASW,CAAU,CAAA,CACxD,CAEJ,CAAC"}