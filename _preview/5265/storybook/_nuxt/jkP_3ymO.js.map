{"version":3,"file":"jkP_3ymO.js","sources":["../../shared/constants/screens.ts","../../shared/utils/translation-banner.ts","../../src/stores/ui.ts"],"sourcesContent":["/**\n * `RealBreakpoints` excludes 'xs' because it's not defined in\n * Tailwind (being mobile-first) but is used in JavaScript to refer to mobile\n * screens that are narrower than 640px ('sm').\n */\nexport type Breakpoint = \"2xl\" | \"xl\" | \"lg\" | \"md\" | \"sm\" | \"xs\"\nexport type RealBreakpoint = Exclude<Breakpoint, \"xs\">\nexport type Viewport = {\n  name: string\n  styles: { width: string; height: string }\n}\n\n/**\n * Mapping of breakpoint names to the lower-bound of their screen width range.\n */\nexport const SCREEN_SIZES = Object.freeze({\n  \"2xl\": 1536,\n  xl: 1280,\n  lg: 1024,\n  md: 768,\n  sm: 640,\n} as const)\n\n/**\n * The same as SCREEN_SIZES but with the 'xs' breakpoint added for use in JS.\n */\nexport const ALL_SCREEN_SIZES = Object.freeze({\n  ...SCREEN_SIZES,\n  xs: 0,\n} as const)\n\n/**\n * Mapping of breakpoint names to the lower-bound of their screen width range,\n * with the 'px' suffix attached. This is used by Tailwind.\n */\nexport const SCREENS = Object.fromEntries(\n  Object.entries(SCREEN_SIZES)\n    .map(([key, val]) => [key, `${val}px`])\n    .reverse()\n) as Record<RealBreakpoint, string>\n\n/**\n * Mapping of breakpoint names to viewport specifications. This is used by\n * the viewports plugin of Storybook.\n */\nexport const VIEWPORTS = Object.fromEntries(\n  (Object.entries(SCREEN_SIZES) as [Breakpoint, number][])\n    .concat([[\"xs\", 340]])\n    .map(([key, val]) => [\n      key,\n      {\n        name: `${key} (${val}px)`,\n        styles: { width: `${val}px`, height: \"768px\" },\n      },\n    ])\n) as Record<Breakpoint, Viewport>\n","import type { LocaleObject } from \"@nuxtjs/i18n\"\n\nconst BASE_URL = \"https://translate.wordpress.org/projects/meta/openverse/\"\n// We show the banner if the translation is less than this percentage\nconst MINIMUM_TRANSLATION_PERCENTAGE = 90\n\nexport const needsTranslationBanner = (locale: LocaleObject) => {\n  if (!locale || locale.code === \"en\") {\n    return false\n  }\n\n  return (locale.translated ?? 100) <= MINIMUM_TRANSLATION_PERCENTAGE\n}\n\nexport const createTranslationLink = (locale: LocaleObject) =>\n  `${BASE_URL}${locale.code || \"en\"}/default/`\n","import { useCookie } from \"#imports\"\n\nimport { LocaleObject } from \"@nuxtjs/i18n\"\nimport { defineStore } from \"pinia\"\n\nimport type { RealBreakpoint } from \"#shared/constants/screens\"\nimport { ALL_SCREEN_SIZES } from \"#shared/constants/screens\"\nimport { needsTranslationBanner } from \"#shared/utils/translation-banner\"\nimport type { BannerId } from \"#shared/types/banners\"\nimport {\n  defaultPersistientCookieState,\n  type OpenverseCookieState,\n  persistentCookieOptions,\n} from \"#shared/types/cookies\"\n\nconst desktopBreakpoints: RealBreakpoint[] = [\"2xl\", \"xl\", \"lg\"]\n\nexport type SnackbarState = \"not_shown\" | \"visible\" | \"dismissed\"\nexport type ColorMode = \"dark\" | \"light\" | \"system\"\n\nexport function isColorMode(value: undefined | string): value is ColorMode {\n  return (\n    typeof value === \"string\" && [\"light\", \"dark\", \"system\"].includes(value)\n  )\n}\n\nexport interface UiState {\n  /**\n   * whether to show the instructions snackbar.\n   */\n  instructionsSnackbarState: SnackbarState\n  /**\n   * whether the filters are shown (sidebar on desktop or modal on mobile).\n   * This is the inner value, components should use the un-prefixed getter.\n   */\n  innerFilterVisible: boolean\n  /**\n   * (only for desktop layout) whether the filters were dismissed. If true,\n   * the filters should be closed on SSR for the first load on desktop layout.\n   */\n  isFilterDismissed: boolean\n  /**\n   * whether the site layout is desktop (or mobile).\n   */\n  isDesktopLayout: boolean\n  /**\n   * the screen's max-width breakpoint.\n   */\n  breakpoint: RealBreakpoint\n  /**\n   * whether the request user agent is mobile or not.\n   */\n  dismissedBanners: BannerId[]\n  /**\n   * Whether to blur sensitive content in search and single result pages.\n   * Value should *not* be set directly, use setShouldBlurSensitive(value: boolean)\n   * to ensure necessary side-effects are executed.\n   */\n  shouldBlurSensitive: boolean\n  /* A list of sensitive single result UUIDs the user has opted-into seeing */\n  revealedSensitiveResults: string[]\n  headerHeight: number\n\n  /* The user-chosen color theme of the site. */\n  colorMode: ColorMode\n  /** whether the user has seen the dark mode toggle */\n  isDarkModeSeen: boolean\n}\n\nexport const breakpoints = Object.keys(ALL_SCREEN_SIZES)\n\nexport const defaultUiState: UiState = {\n  instructionsSnackbarState: \"not_shown\",\n  innerFilterVisible: false,\n  isFilterDismissed: false,\n  isDesktopLayout: false,\n  breakpoint: \"sm\",\n  dismissedBanners: [],\n  shouldBlurSensitive: true,\n  revealedSensitiveResults: [],\n  headerHeight: 80,\n  colorMode: \"system\",\n  isDarkModeSeen: false,\n}\n\nexport const useUiStore = defineStore(\"ui\", {\n  state: (): UiState => ({ ...defaultUiState }),\n\n  getters: {\n    cookieState(state): OpenverseCookieState[\"ui\"] {\n      return {\n        instructionsSnackbarState: state.instructionsSnackbarState,\n        isFilterDismissed: state.isFilterDismissed,\n        breakpoint: state.breakpoint,\n        dismissedBanners: Array.from(this.dismissedBanners),\n        colorMode: state.colorMode,\n        isDarkModeSeen: state.isDarkModeSeen,\n      }\n    },\n    areInstructionsVisible(state): boolean {\n      return state.instructionsSnackbarState === \"visible\"\n    },\n\n    /**\n     * On desktop, we only hide the filters sidebar if it was\n     * specifically dismissed on the desktop layout.\n     *\n     * The filters state could diverge if the layout changed from desktop to mobile:\n     * closing the filters on mobile sets `isFilterVisible` to false, but does not\n     * save the `isFilterDismissed` because it only applies on the desktop layout.\n     *\n     * This getter correct the state if it diverged, and then returns the visibility state.\n     */\n    isFilterVisible(state: UiState): boolean {\n      if (\n        state.isDesktopLayout &&\n        !state.isFilterDismissed &&\n        !state.innerFilterVisible\n      ) {\n        state.innerFilterVisible = true\n      }\n      return state.innerFilterVisible\n    },\n    /**\n     * The analytics banner is shown if the user hasn't dismissed it yet.\n     */\n    shouldShowAnalyticsBanner(): boolean {\n      return !this.dismissedBanners.includes(\"analytics\")\n    },\n  },\n\n  actions: {\n    /**\n     * The translation banner is shown if the translated percentage is below 90%,\n     * and the banner for the current locale was not dismissed (status from cookies).\n     */\n    shouldShowTranslationBanner(localeProperties: LocaleObject): boolean {\n      const locale = localeProperties.code\n      return (\n        !this.dismissedBanners.includes(`translation-${locale}`) &&\n        needsTranslationBanner(localeProperties)\n      )\n    },\n    showInstructionsSnackbar() {\n      if (this.instructionsSnackbarState === \"not_shown\") {\n        this.instructionsSnackbarState = \"visible\"\n      }\n    },\n\n    hideInstructionsSnackbar() {\n      if (this.instructionsSnackbarState === \"visible\") {\n        this.instructionsSnackbarState = \"not_shown\"\n      }\n    },\n\n    dismissInstructionsSnackbar() {\n      this.instructionsSnackbarState = \"dismissed\"\n    },\n\n    /**\n     * Given a list of key value pairs of UI state parameters and their states,\n     * populate the store state to match the cookie.\n     *\n     * Since the cookies are passed through `JSON.parse()`, they can have the\n     * wrong types. This function resets cookies to the default value if their\n     * type is incorrect.\n     *\n     * @param cookies - mapping of UI state parameters and their states.\n     */\n    initFromCookies(cookies: OpenverseCookieState[\"ui\"]) {\n      let breakpoint = this.breakpoint\n      if (\n        cookies.breakpoint &&\n        Object.keys(ALL_SCREEN_SIZES).includes(cookies.breakpoint)\n      ) {\n        breakpoint = cookies.breakpoint\n      }\n      this.updateBreakpoint(breakpoint, false)\n\n      if (typeof cookies.isFilterDismissed === \"boolean\") {\n        this.isFilterDismissed = cookies.isFilterDismissed\n      }\n\n      this.innerFilterVisible = this.isDesktopLayout\n        ? !this.isFilterDismissed\n        : false\n\n      if (Array.isArray(cookies.dismissedBanners)) {\n        this.dismissedBanners = cookies.dismissedBanners\n      }\n\n      if (isColorMode(cookies.colorMode)) {\n        this.setColorMode(cookies.colorMode, false)\n      }\n\n      if (typeof cookies.isDarkModeSeen === \"boolean\") {\n        this.setIsDarkModeSeen(cookies.isDarkModeSeen, false)\n      }\n\n      this.writeToCookie()\n    },\n    /**\n     * Write the current state of the feature flags to the cookie. These cookies\n     * are read in the corresponding `initFromCookies` method.\n     */\n    writeToCookie() {\n      const uiCookie = useCookie<OpenverseCookieState[\"ui\"]>(\n        \"ui\",\n        persistentCookieOptions\n      )\n\n      uiCookie.value = {\n        ...defaultPersistientCookieState.ui,\n        ...this.cookieState,\n      }\n    },\n\n    /**\n     * If the breakpoint is different from the state, updates the state, and saves it into app cookies.\n     *\n     * @param breakpoint - the `min-width` tailwind breakpoint for the screen width.\n     * @param saveToCookie - whether to save the new breakpoint in the cookie.\n     */\n    updateBreakpoint(breakpoint: RealBreakpoint, saveToCookie = true) {\n      if (this.breakpoint === breakpoint) {\n        return\n      }\n\n      this.breakpoint = breakpoint\n\n      if (saveToCookie) {\n        this.writeToCookie()\n      }\n\n      this.isDesktopLayout = desktopBreakpoints.includes(breakpoint)\n    },\n\n    /**\n     * Sets the filter state based on the `visible` parameter.\n     * If the filter state is changed on desktop, updates the `isFilterDismissed`\n     * 'ui' cookie value.\n     *\n     * @param visible - whether the filters should be visible.\n     */\n    setFiltersState(visible: boolean) {\n      this.innerFilterVisible = visible\n      if (this.isDesktopLayout) {\n        this.isFilterDismissed = !visible\n\n        this.writeToCookie()\n      }\n    },\n\n    /**\n     * Toggles filter state and saves the new state in a cookie.\n     */\n    toggleFilters() {\n      this.setFiltersState(!this.isFilterVisible)\n    },\n    /**\n     * If the banner wasn't dismissed before, dismisses it and saves the new state in a cookie.\n     * @param bannerId - the id of the banner to dismiss.\n     */\n    dismissBanner(bannerId: BannerId) {\n      if (this.dismissedBanners.includes(bannerId)) {\n        return\n      }\n\n      this.dismissedBanners.push(bannerId)\n\n      this.writeToCookie()\n    },\n    isBannerDismissed(bannerId: BannerId) {\n      return this.dismissedBanners.includes(bannerId)\n    },\n    /**\n     * Similar to CSS `@media` queries, this function returns a boolean\n     * indicating whether the current breakpoint is greater than or equal to\n     * the breakpoint passed as a parameter.\n     */\n    isBreakpoint(breakpoint: RealBreakpoint): boolean {\n      return (\n        breakpoints.indexOf(breakpoint) >= breakpoints.indexOf(this.breakpoint)\n      )\n    },\n    setShouldBlurSensitive(value: boolean) {\n      this.shouldBlurSensitive = value\n      this.revealedSensitiveResults = []\n    },\n\n    /**\n     * Update the user's preferred color mode.\n     *\n     * @param colorMode - the user's preferred color mode.\n     * @param saveToCookie - whether to save the new breakpoint in the cookie.\n     */\n    setColorMode(colorMode: ColorMode, saveToCookie = true) {\n      this.colorMode = colorMode\n\n      if (saveToCookie) {\n        this.writeToCookie()\n      }\n    },\n\n    /**\n     * Update the value of whether the user has seen dark mode.\n     *\n     * @param value - the new value of whether the user has seen dark mode\n     * @param saveToCookie - whether to save the new breakpoint in the cookie.\n     */\n    setIsDarkModeSeen(value: boolean, saveToCookie = true) {\n      this.isDarkModeSeen = value\n\n      if (saveToCookie) {\n        this.writeToCookie()\n      }\n    },\n    setHeaderHeight(height: number) {\n      this.headerHeight = Math.max(height, 80)\n    },\n  },\n})\n"],"names":["SCREEN_SIZES","ALL_SCREEN_SIZES","key","val","VIEWPORTS","BASE_URL","MINIMUM_TRANSLATION_PERCENTAGE","needsTranslationBanner","locale","createTranslationLink","desktopBreakpoints","isColorMode","value","breakpoints","defaultUiState","useUiStore","defineStore","state","localeProperties","cookies","breakpoint","uiCookie","useCookie","persistentCookieOptions","defaultPersistientCookieState","saveToCookie","visible","bannerId","colorMode","height"],"mappings":"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"}