{"version":3,"file":"I6oWuQE1.js","sources":["../../shared/constants/feature-flag.ts","../../shared/constants/deploy-env.ts","../../src/stores/feature-flag.ts"],"sourcesContent":["export const ENABLED = \"enabled\"\nexport const DISABLED = \"disabled\"\nexport const SWITCHABLE = \"switchable\"\n\nexport const FLAG_STATUSES = [ENABLED, DISABLED, SWITCHABLE] as const\n\nexport type FlagStatus = (typeof FLAG_STATUSES)[number]\n\nexport const ON = \"on\"\nexport const OFF = \"off\"\n\nexport const FEATURE_STATES = [ON, OFF] as const\n\nexport type FeatureState = (typeof FEATURE_STATES)[number]\n\nexport const SESSION = \"session\"\nexport const COOKIE = \"cookie\"\n\nexport const STORAGES = [SESSION, COOKIE] as const\n\nexport type Storage = (typeof STORAGES)[number]\n","export const LOCAL = \"local\"\nexport const STAGING = \"staging\"\nexport const PRODUCTION = \"production\"\n\n// The order of the environments is important. They should be arranged in\n// increasing order of code-readiness, from local to production.\nexport const DEPLOY_ENVS = [LOCAL, STAGING, PRODUCTION] as const\n\nexport type DeployEnv = (typeof DEPLOY_ENVS)[number]\n","import { tryUseNuxtApp, useCookie } from \"#imports\"\n\nimport { defineStore } from \"pinia\"\nimport { useStorage } from \"@vueuse/core\"\nimport featureData from \"~~/feat/feature-flags.json\"\n\nimport {\n  COOKIE,\n  DISABLED,\n  ENABLED,\n  FeatureState,\n  FLAG_STATUSES,\n  FlagStatus,\n  OFF,\n  ON,\n  SESSION,\n  SWITCHABLE,\n} from \"#shared/constants/feature-flag\"\nimport { DEPLOY_ENVS, DeployEnv } from \"#shared/constants/deploy-env\"\nimport type {\n  FeatureFlag,\n  FeatureFlagRecord,\n  FlagName,\n} from \"#shared/types/feature-flag\"\nimport {\n  type OpenverseCookieState,\n  persistentCookieOptions,\n  sessionCookieOptions,\n} from \"#shared/types/cookies\"\nimport { warn } from \"~/utils/console\"\n\nimport type { LocationQuery, LocationQueryValue } from \"vue-router\"\n\nexport const isFlagName = (name: string): name is FlagName => {\n  return Object.keys(featureData.features).includes(name)\n}\nexport interface FeatureFlagState {\n  flags: Record<FlagName, FeatureFlag>\n}\n\ninterface FeatureGroup {\n  title: string\n  features: FeatureFlag[]\n}\n\n/**\n * Get the status of the flag. If the flag status is environment dependent, this\n * function will use the flag status for the current environment based on the\n * value from the runtime config.\n *\n * @param flag - the flag for which to get the status\n * @param deploymentEnv - the current deployment environment\n */\nexport const getFlagStatus = (\n  flag: FeatureFlagRecord,\n  deploymentEnv: DeployEnv\n): FlagStatus => {\n  if (typeof flag.status === \"string\") {\n    if (!FLAG_STATUSES.includes(flag.status as FlagStatus)) {\n      warn(`Invalid ${flag.description} flag status: ${flag.status}`)\n      return DISABLED\n    }\n    return flag.status as FlagStatus\n  } else {\n    const envIndex = DEPLOY_ENVS.indexOf(deploymentEnv)\n    for (let i = envIndex; i < DEPLOY_ENVS.length; i += 1) {\n      if (DEPLOY_ENVS[i] in flag.status) {\n        if (\n          !FLAG_STATUSES.includes(flag.status[DEPLOY_ENVS[i]] as FlagStatus)\n        ) {\n          warn(\n            `Invalid ${flag.description} flag status: ${flag.status[DEPLOY_ENVS[i]]}`\n          )\n          return DISABLED\n        }\n        return flag.status[DEPLOY_ENVS[i]] as FlagStatus\n      }\n    }\n  }\n  return DISABLED\n}\n\n/**\n * Get the state of the feature based on the status of the feature flag and the\n * preferences of the user.\n *\n * @param flag - the flag for which to get the state\n * @param deploymentEnv - the current deployment environment\n */\nconst getFeatureState = (\n  flag: FeatureFlag | FeatureFlagRecord,\n  deploymentEnv: DeployEnv\n): FeatureState => {\n  const status = getFlagStatus(flag, deploymentEnv)\n  if (status === SWITCHABLE) {\n    if (\"preferredState\" in flag) {\n      return (flag.preferredState as FeatureState) ?? flag.defaultState ?? OFF\n    }\n    return flag.defaultState ?? OFF\n  }\n  if (status === ENABLED) {\n    return ON\n  }\n  return OFF\n}\n\nexport const initializeFlagState = (deploymentEnv: DeployEnv) => {\n  // Resolve the status of the feature flags based on the current environment\n  const features: Record<FlagName, FeatureFlag> = Object.entries(\n    featureData.features as Record<FlagName, FeatureFlagRecord>\n  ).reduce(\n    (acc, [name, flag]) => {\n      acc[name as FlagName] = {\n        ...flag,\n        name: name as FlagName,\n        state: getFeatureState(flag, deploymentEnv),\n        status: getFlagStatus(flag, deploymentEnv),\n        preferredState: undefined,\n      }\n      return acc\n    },\n    {} as Record<FlagName, FeatureFlag>\n  )\n  return { flags: features, groups: featureData.groups }\n}\n\nconst FEATURE_FLAG = \"feature_flag\"\n\nexport const useFeatureFlagStore = defineStore(FEATURE_FLAG, {\n  state: () => {\n    const nuxtApp = tryUseNuxtApp()\n    if (nuxtApp) {\n      return initializeFlagState(\n        nuxtApp.$config.public.deploymentEnv as DeployEnv\n      )\n    }\n\n    throw new Error(\n      \"Could not set up feature flag store because Nuxt content isn't available.\"\n    )\n  },\n  getters: {\n    /**\n     * Get the state of the named feature, based on config and cookie.\n     *\n     * Prefer `isOn` for most use cases.\n     */\n    featureState:\n      (state: FeatureFlagState) =>\n      (name: FlagName): FeatureState => {\n        if (!isFlagName(name)) {\n          warn(`Invalid feature flag accessed: ${name}`)\n          return ON\n        }\n        return state.flags[name].state\n      },\n\n    /**\n     * Get the mapping of switchable features to their preferred states.\n     */\n    flagStateMap:\n      (state: FeatureFlagState) =>\n      (dest: string): Record<string, FeatureState> => {\n        const featureMap: Record<string, FeatureState> = {}\n        Object.entries(state.flags).forEach(([name, flag]) => {\n          if (\n            flag.status === SWITCHABLE &&\n            flag.preferredState !== undefined &&\n            flag.storage === dest\n          ) {\n            featureMap[name] = flag.state\n          }\n        })\n        return featureMap\n      },\n  },\n  actions: {\n    getFlagsBySwitchable(switchable: boolean): FeatureFlag[] {\n      return Object.entries(this.flags)\n        .filter((feature) => (feature[1].status === SWITCHABLE) === switchable)\n        .map((feature) => feature[1])\n    },\n\n    getFeatureGroups() {\n      const result: FeatureGroup[] = []\n      for (const { title, features } of this.groups) {\n        if (features.length === 0) {\n          continue\n        }\n        result.push({\n          title,\n          features: features.map((name) => this.flags[name as FlagName]),\n        })\n      }\n      return result\n    },\n    /**\n     * Given a list of key value pairs of flags and their preferred states,\n     * populate the store state to match the cookie. The cookie may be\n     * persistent, if written by `writeToCookie`, or session-scoped, if written\n     * by `writeToSession`.\n     *\n     * @param cookies - mapping of feature flags and their preferred states\n     */\n    initFromCookies(cookies: Record<string, FeatureState>) {\n      Object.entries(cookies).forEach(([name, state]) => {\n        const flag = this.flags[name as FlagName]\n        if (flag && flag.status === SWITCHABLE) {\n          this.setPreferredState(name as FlagName, state)\n        }\n      })\n    },\n    /**\n     * Write the current state of the feature flags to the cookie. These cookies\n     * are read in the corresponding `initFromCookies` method.\n     */\n    writeToCookie() {\n      const featuresCookie = useCookie<OpenverseCookieState[\"features\"]>(\n        \"features\",\n        persistentCookieOptions\n      )\n      featuresCookie.value = this.flagStateMap(COOKIE)\n    },\n    /**\n     * Write the current state of the switchable flags to the session cookie.\n     * These cookies are read in the corresponding `initFromCookies` method.\n     *\n     * This is same as `writeToCookie`, except these cookies are not persistent\n     * and will be deleted by the browser after the session.\n     */\n    writeToSession() {\n      const sessionFeaturesCookie = useCookie<\n        OpenverseCookieState[\"sessionFeatures\"]\n      >(\"sessionFeatures\", sessionCookieOptions)\n      sessionFeaturesCookie.value = this.flagStateMap(SESSION)\n    },\n    /**\n     * Set the value of flag entries from the query parameters. Only those\n     * query parameters that contain the 'ff_' prefix are considered.\n     *\n     * Values set using query params are per-session, and will not affect the\n     * value stored in the cookie.\n     *\n     * @param query - values for the feature flags\n     */\n    initFromQuery(query: LocationQuery) {\n      const isValidName = (name: string): name is `ff_${FlagName}` =>\n        name.startsWith(\"ff_\") && name.replace(\"ff_\", \"\") in this.flags\n      const isValidValue = (\n        value: LocationQueryValue | LocationQueryValue[]\n      ): value is FeatureState =>\n        typeof value === \"string\" && [\"on\", \"off\"].includes(value)\n      const isValidEntry = (\n        entry: [string, LocationQueryValue | LocationQueryValue[]]\n      ): entry is [`ff_${FlagName}`, FeatureState] =>\n        isValidName(entry[0]) && isValidValue(entry[1])\n\n      Object.entries(query)\n        .filter(isValidEntry)\n        .forEach(([name, state]) => {\n          // TODO: type `FlagName` should be inferred by TS\n          const flagName = name.substring(3) as FlagName\n          const flag = this.flags[flagName]\n          if (flag.status === SWITCHABLE && flag.supportsQuery !== false) {\n            this.setPreferredState(flagName, state)\n          }\n        })\n    },\n    setPreferredState(name: FlagName, toState: FeatureState) {\n      const flag = this.flags[name]\n      if (flag.status === SWITCHABLE) {\n        flag.preferredState = toState\n        flag.state = toState\n      }\n    },\n    updateStorage(name: FlagName) {\n      const flag = this.flags[name]\n      if (flag.storage === COOKIE) {\n        this.writeToCookie()\n      } else if (flag.storage === SESSION) {\n        this.writeToSession()\n      }\n      if (name === \"analytics\") {\n        this.syncAnalyticsWithLocalStorage()\n      }\n    },\n    /**\n     * Toggle the feature flag of the given name to the given preferred state.\n     *\n     * @param name - the name of the flag to toggle\n     * @param targetState - the desired state of the feature flag\n     */\n    toggleFeature(name: FlagName, targetState: FeatureState) {\n      if (!isFlagName(name)) {\n        throw new Error(`Toggling invalid feature flag: ${name}`)\n      }\n      const flag = this.flags[name]\n      if (flag.status === SWITCHABLE) {\n        this.setPreferredState(name, targetState)\n        this.updateStorage(name)\n      } else {\n        warn(`Cannot set preferred state for non-switchable flag: ${name}`)\n      }\n    },\n    /**\n     * For Plausible to stop tracking `plausible_ignore` must be set in\n     * `localStorage`.\n     * @see {@link https://plausible.io/docs/excluding-localstorage}\n     */\n    syncAnalyticsWithLocalStorage() {\n      const storage = useStorage<boolean | null>(\"plausible_ignore\", null)\n      storage.value = this.flags.analytics.state === ON ? null : true\n    },\n\n    isSwitchable(name: FlagName) {\n      if (!isFlagName(name)) {\n        throw new Error(`Invalid feature flag accessed: ${name}`)\n      }\n      return this.flags[name].status === SWITCHABLE\n    },\n    /**\n     * Proxy for `featureState` to simplify the majority of flag state checks.\n     *\n     * Prefer this for most use cases over using `featureState` directly.\n     *\n     * @returns `true` if the flag is on, false otherwise\n     */\n    isOn(name: FlagName) {\n      if (!isFlagName(name)) {\n        throw new Error(`Invalid feature flag accessed: ${name}`)\n      }\n      return this.flags[name].state === ON\n    },\n  },\n})\n"],"names":["ENABLED","DISABLED","SWITCHABLE","FLAG_STATUSES","ON","OFF","SESSION","COOKIE","LOCAL","STAGING","PRODUCTION","DEPLOY_ENVS","isFlagName","name","featureData","getFlagStatus","flag","deploymentEnv","warn","envIndex","i","getFeatureState","status","initializeFlagState","acc","FEATURE_FLAG","useFeatureFlagStore","defineStore","nuxtApp","tryUseNuxtApp","state","dest","featureMap","switchable","feature","result","title","features","cookies","featuresCookie","useCookie","persistentCookieOptions","sessionFeaturesCookie","sessionCookieOptions","query","isValidName","isValidValue","value","isValidEntry","entry","flagName","toState","targetState","storage","useStorage"],"mappings":"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"}