{"version":3,"file":"Co6bLswe.js","sources":["../../shared/types/tabs.ts","../../src/utils/dom.ts","../../src/utils/focus-management.ts","../../src/components/VTabs/VTab.vue","../../src/components/VTabs/VTabs.vue"],"sourcesContent":["import type {\n  ComputedRef,\n  InjectionKey,\n  Ref,\n  ComponentPublicInstance,\n} from \"vue\"\n\nexport type TabActivation = \"manual\" | \"auto\"\nexport type TabVariant = \"bordered\" | \"plain\"\nexport type TabsState = {\n  // State\n  selectedId: Ref<string>\n\n  activation: ComputedRef<TabActivation>\n  variant: ComputedRef<TabVariant>\n\n  tabs: Ref<Ref<HTMLElement | ComponentPublicInstance | null>[]>\n  panels: Ref<Ref<HTMLElement | null>[]>\n\n  // State mutators\n  setSelectedId(id: string): void\n  registerTab(tab: Ref<HTMLElement | null>): void\n  unregisterTab(tab: Ref<HTMLElement | null>): void\n  registerPanel(panel: Ref<HTMLElement | null>): void\n  unregisterPanel(panel: Ref<HTMLElement | null>): void\n}\nexport const tabsContextKey = Symbol() as InjectionKey<TabsState>\n","// Credit: https://github.com/tailwindlabs/headlessui/\nimport type { Ref, ComponentPublicInstance } from \"vue\"\n\nexport function getDomElement<T extends Element | ComponentPublicInstance>(\n  ref?: Ref<T | null>\n): T | null {\n  if (ref == null) {\n    return null\n  }\n  if (ref.value == null) {\n    return null\n  }\n\n  return \"$el\" in ref.value ? (ref.value.$el as T | null) : ref.value\n}\n","// Credit: https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-vue/src/utils/focus-management.ts\nimport type { Ref } from \"vue\"\n\nimport { getDomElement } from \"~/utils/dom\"\n\nfunction getOwnerDocument<T extends Element | Ref<Element | null>>(\n  element: T | null | undefined\n) {\n  if (typeof window === \"undefined\") {\n    return null\n  }\n  if (element instanceof Node) {\n    return element.ownerDocument\n  }\n  if (element && Object.prototype.hasOwnProperty.call(element, \"value\")) {\n    const domElement = getDomElement(element)\n    if (domElement) {\n      return domElement.ownerDocument\n    }\n  }\n\n  return document\n}\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nconst focusableSelector = [\n  \"[contentEditable=true]\",\n  \"[tabindex]\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"iframe\",\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\",\n]\n  .map(\n    import.meta.test\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        (selector) =>\n          `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : (selector) => `${selector}:not([tabindex='-1'])`\n  )\n  .join(\",\")\n\nexport const Focus = Object.freeze({\n  /** Focus the first non-disabled element */\n  First: 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous: 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next: 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last: 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround: 1 << 4,\n})\n\nexport const FocusResult = Object.freeze({\n  Error: \"Error\" as const,\n  Overflow: \"Overflow\" as const,\n  Success: \"Success\" as const,\n  Underflow: \"Underflow\" as const,\n})\n\nexport const Direction = Object.freeze({ Next: 1, Previous: -1 })\n\nexport function getFocusableElements(\n  container: HTMLElement | null = document.body\n) {\n  if (container == null) {\n    return []\n  }\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport function isFocusableElement(element: HTMLElement) {\n  if (element === getOwnerDocument(element)?.body) {\n    return false\n  }\n  return element.matches(focusableSelector)\n}\n\nexport function focusElement(element: HTMLElement | Element | null) {\n  if (element instanceof HTMLElement) {\n    element.focus()\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select\nconst selectableSelector = [\"textarea\", \"input\"].join(\",\")\nfunction isSelectableElement(\n  element: Element | null\n): element is HTMLInputElement | HTMLTextAreaElement {\n  return element?.matches?.(selectableSelector) ?? false\n}\n\nexport function sortByDomNode<T>(\n  nodes: T[],\n  resolveKey: (item: T) => HTMLElement | null = (i) =>\n    i as unknown as HTMLElement | null\n): T[] {\n  return nodes.slice().sort((aItem, zItem) => {\n    const a = resolveKey(aItem)\n    const z = resolveKey(zItem)\n\n    if (a === null || z === null) {\n      return 0\n    }\n\n    const position = a.compareDocumentPosition(z)\n\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return -1\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return 1\n    }\n    return 0\n  })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: number) {\n  const ownerDocument =\n    (Array.isArray(container)\n      ? container.length > 0\n        ? container[0].ownerDocument\n        : document\n      : container?.ownerDocument) ?? document\n\n  const elements = Array.isArray(container)\n    ? sortByDomNode(container)\n    : getFocusableElements(container)\n  const active = ownerDocument.activeElement as HTMLElement\n\n  const direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) {\n      return Direction.Next\n    }\n    if (focus & (Focus.Previous | Focus.Last)) {\n      return Direction.Previous\n    }\n\n    throw new Error(\n      \"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\"\n    )\n  })()\n\n  const startIndex = (() => {\n    if (focus & Focus.First) {\n      return 0\n    }\n    if (focus & Focus.Previous) {\n      return Math.max(0, elements.indexOf(active)) - 1\n    }\n    if (focus & Focus.Next) {\n      return Math.max(0, elements.indexOf(active)) + 1\n    }\n    if (focus & Focus.Last) {\n      return elements.length - 1\n    }\n\n    throw new Error(\n      \"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\"\n    )\n  })()\n\n  let offset = 0\n  const total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) {\n      return FocusResult.Error\n    }\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) {\n        return FocusResult.Underflow\n      }\n      if (nextIdx >= total) {\n        return FocusResult.Overflow\n      }\n    }\n\n    next = elements[nextIdx]\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus()\n    // Try the next one in line\n    offset += direction\n  } while (next !== ownerDocument.activeElement)\n  if (\n    !next.hasAttribute(\"tabindex\") ||\n    next.getAttribute(\"tabindex\") === \"-1\"\n  ) {\n    next.setAttribute(\"tabindex\", \"0\")\n  }\n\n  if (focus & (Focus.Next | Focus.Previous) && isSelectableElement(next)) {\n    next.select()\n  }\n\n  return FocusResult.Success\n}\n","<script setup lang=\"ts\">\nimport { computed, inject, onMounted, onUnmounted, ref } from \"vue\"\n\nimport { keycodes } from \"#shared/constants/key-codes\"\nimport { tabsContextKey, type TabsState } from \"#shared/types/tabs\"\nimport { getDomElement } from \"~/utils/dom\"\nimport { Focus, focusIn } from \"~/utils/focus-management\"\n\nimport VButton from \"~/components/VButton.vue\"\n\nconst props = withDefaults(\n  defineProps<{\n    /**\n     * Tab id should be the same as the id of the tabpanel it controls.\n     * The id of the HTML element will be `tab-${id}`\n     */\n    id: string\n    /**\n     * Whether the tab is disabled. TODO: do we really need disabled tabs?\n     */\n    disabled?: boolean\n    size?: \"default\" | \"large\" | \"medium\"\n  }>(),\n  {\n    disabled: false,\n    size: \"default\",\n  }\n)\n\nconst injectedTabContext = inject(tabsContextKey)\nif (!injectedTabContext) {\n  throw new Error(`Could not resolve tabContext in VTab`)\n}\nconst tabContext = injectedTabContext as TabsState\n\nconst internalTabRef = ref<HTMLElement | null>(null)\n\nonMounted(() => tabContext.registerTab(internalTabRef))\nonUnmounted(() => tabContext.unregisterTab(internalTabRef))\n\nconst isSelected = computed(() => tabContext.selectedId.value === props.id)\n\nconst handleFocus = () => {\n  if (props.disabled) {\n    return\n  }\n  if (tabContext.activation.value === \"auto\") {\n    tabContext.setSelectedId(props.id)\n  }\n  getDomElement(internalTabRef)?.focus()\n}\n\nconst handleSelection = () => {\n  if (props.disabled) {\n    return\n  }\n  getDomElement(internalTabRef)?.focus()\n  tabContext.setSelectedId(props.id)\n}\n\n/**\n* On click, you get a `focus` and then a `click` event. We want to only focus\n* _after_ the click event is finished(mouseup), or when the tab gets focus.\n\n* @param event - we want to preventDefault for this mouse event\n*/\nconst handleMouseDown = (event: MouseEvent) => {\n  event.preventDefault()\n}\n\n/**\n * Sets the direction where to move focus considering the document direction (ltr or rtl).\n * The directions for LTR are the opposite of RTL directions.\n * @param arrowKeyCode - the code of key pressed, right or left arrow\n * @param documentDir - the dir attribute of the current document.\n */\nconst getFocusDirection = (\n  arrowKeyCode: typeof keycodes.ArrowRight | typeof keycodes.ArrowLeft,\n  documentDir?: string\n) => {\n  let forward = arrowKeyCode === keycodes.ArrowRight\n  if (documentDir === \"rtl\") {\n    forward = !forward\n  }\n  return forward ? Focus.Next : Focus.Previous\n}\n\nconst handleKeyDown = (event: KeyboardEvent) => {\n  const list = tabContext.tabs.value\n    .map((tab) => getDomElement(tab))\n    .filter(Boolean) as HTMLElement[]\n  const tabControlKeys = [\n    keycodes.Spacebar,\n    keycodes.Enter,\n    keycodes.Home,\n    keycodes.PageUp,\n    keycodes.End,\n    keycodes.PageDown,\n    keycodes.ArrowLeft,\n    keycodes.ArrowRight,\n  ] as string[]\n\n  if (!tabControlKeys.includes(event.key)) {\n    return\n  }\n  event.preventDefault()\n  event.stopPropagation()\n\n  switch (event.key) {\n    case keycodes.Spacebar:\n    case keycodes.Enter: {\n      tabContext.setSelectedId(props.id)\n      break\n    }\n    case keycodes.Home:\n    case keycodes.PageUp: {\n      focusIn(list, Focus.First)\n      break\n    }\n\n    case keycodes.End:\n    case keycodes.PageDown: {\n      focusIn(list, Focus.Last)\n      break\n    }\n    case keycodes.ArrowLeft: {\n      focusIn(\n        list,\n        getFocusDirection(keycodes.ArrowLeft, document.dir) | Focus.WrapAround\n      )\n      break\n    }\n\n    case keycodes.ArrowRight: {\n      focusIn(\n        list,\n        getFocusDirection(keycodes.ArrowRight, document.dir) | Focus.WrapAround\n      )\n      break\n    }\n  }\n}\n\nconst tabProps = computed(() => ({\n  \"aria-controls\": `panel-${props.id}`,\n  \"aria-selected\": isSelected.value,\n  disabled: props.disabled ? true : undefined,\n}))\n\nconst variant = computed(() => tabContext.variant.value)\n</script>\n\n<template>\n  <VButton\n    :id=\"`tab-${id}`\"\n    ref=\"internalTabRef\"\n    role=\"tab\"\n    :tabindex=\"isSelected ? 0 : -1\"\n    size=\"disabled\"\n    variant=\"plain--avoid\"\n    v-bind=\"tabProps\"\n    class=\"rounded-none bg-default focus:z-10 focus-visible:focus-slim-tx\"\n    :class=\"[variant, `size-${size}`, { [`${variant}-selected`]: isSelected }]\"\n    @click=\"handleSelection\"\n    @focus=\"handleFocus\"\n    @mousedown=\"handleMouseDown\"\n    @keydown=\"handleKeyDown\"\n  >\n    <slot />\n  </VButton>\n</template>\n\n<style scoped>\n.bordered {\n  @apply rounded-se-sm rounded-ss-sm border-x border-t border-tx text-sm font-semibold md:text-base md:font-semibold md:leading-snug;\n}\n.plain {\n  @apply rounded-sm border-tx bg-tx text-sm hover:bg-secondary;\n}\n.bordered-selected {\n  @apply -mb-[1px] border border-x-default border-b-tx border-t-default bg-default;\n}\n.plain-selected {\n  @apply relative after:absolute after:right-1/2 after:h-0.5 after:w-full after:translate-x-1/2 after:translate-y-[-50%] after:bg-tertiary after:transition-all after:duration-200;\n}\n.plain-selected.size-default {\n  @apply after:bottom-[-0.125rem];\n}\n.size-default {\n  @apply px-4 py-3 md:px-6;\n}\n.size-large {\n  @apply h-16;\n}\n.size-medium {\n  @apply h-12 px-2;\n}\n.plain.size-medium {\n  @apply my-2 border-tx;\n}\n.plain-selected.size-medium {\n  @apply after:bottom-[-0.625rem];\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, provide, ref } from \"vue\"\n\nimport { tabsContextKey } from \"#shared/types/tabs\"\nimport type { TabsState, TabVariant } from \"#shared/types/tabs\"\n\n/**\n * VTabs is an accessible implementation of tabs component that displays one panel at a time.\n * @see { https://www.w3.org/TR/wai-aria-practices/#tabpanel }\n * Use the default automatic activation of tabs when the tab button receives focus for panels\n * that can be displayed instantly, without fetching any data. For tab panels that fetch data\n * from the internet or require expensive computation, set `manual` to true to activate the tabs\n * by clicking `Enter` or `Space` after focusing on them using `Tab`.\n *\n * To link the VTab to VTabPanel, make sure to pass the same `id` to both.\n */\nconst props = withDefaults(\n  defineProps<{\n    /**\n     * Accessible name label to use for the tablist.\n     *\n     * Reuse an existing element as a label by passing its `id` starting with `#`.\n     * The tablist's `aria-labelledby` will be set to this element.\n     *\n     * If there are no existing elements that can be used as a label, pass a translated\n     * string to be used as `aria-label`.\n     */\n    label: string\n    /**\n     * By default, the tab panels are activated when the corresponding tabs are focused on.\n     * If the tabs require expensive calculations or fetch data from the network, set manual\n     * to true to only activate the tab panels after user clicks `Enter` or `Space` on the focused\n     * tab.\n     */\n    manual?: boolean\n    /**\n     * `bordered` tabs have a border around the tab panel, and around the selected tab.\n     * `plain` tabs only have a line under the tabs, and a thicker line under the selected tab.\n     */\n    variant?: TabVariant\n    /**\n     * To ensure that a panel is visible on SSR, before we can run `onMounted` hook to register panel.\n     */\n    selectedId: string\n    /**\n     * The classes to pass to the div wrapping VTabs.\n     */\n    tablistStyle?: string\n  }>(),\n  {\n    manual: false,\n    variant: \"bordered\",\n    tabListStyle: \"\",\n  }\n)\nconst emit = defineEmits<{\n  change: [string]\n  close: []\n}>()\n\nconst selectedId = ref<TabsState[\"selectedId\"][\"value\"]>(props.selectedId)\nconst tabs = ref<TabsState[\"tabs\"][\"value\"]>([])\nconst panels = ref<TabsState[\"panels\"][\"value\"]>([])\n\nconst tabGroupContext: TabsState = {\n  selectedId,\n  activation: computed(() => (props.manual ? \"manual\" : \"auto\")),\n  variant: computed(() => props.variant),\n  tabs,\n  panels,\n  setSelectedId(id: string) {\n    if (selectedId.value === id) {\n      return\n    }\n    selectedId.value = id\n    emit(\"change\", id)\n  },\n  registerTab(tab: (typeof tabs)[\"value\"][number]) {\n    if (!tabs.value.includes(tab)) {\n      tabs.value.push(tab)\n    }\n  },\n  unregisterTab(tab: (typeof tabs)[\"value\"][number]) {\n    const idx = tabs.value.indexOf(tab)\n    if (idx !== -1) {\n      tabs.value.splice(idx, 1)\n    }\n  },\n  registerPanel(panel: (typeof panels)[\"value\"][number]) {\n    if (!panels.value.includes(panel)) {\n      panels.value.push(panel)\n    }\n  },\n  unregisterPanel(panel: (typeof panels)[\"value\"][number]) {\n    const idx = panels.value.indexOf(panel)\n    if (idx !== -1) {\n      panels.value.splice(idx, 1)\n    }\n  },\n}\nprovide(tabsContextKey, tabGroupContext)\n\nconst accessibleLabel = computed(() =>\n  props.label.startsWith(\"#\")\n    ? { \"aria-labelledby\": props.label.slice(1) }\n    : { \"aria-label\": props.label }\n)\n</script>\n\n<template>\n  <div>\n    <div\n      role=\"tablist\"\n      class=\"flex flex-row items-stretch\"\n      :class=\"tablistStyle\"\n      v-bind=\"accessibleLabel\"\n    >\n      <slot name=\"tabs\" />\n    </div>\n    <slot name=\"default\" />\n  </div>\n</template>\n"],"names":["tabsContextKey","getDomElement","ref","focusableSelector","selector","Focus","FocusResult","Direction","getFocusableElements","container","focusElement","element","selectableSelector","isSelectableElement","_a","sortByDomNode","nodes","resolveKey","i","aItem","zItem","a","z","position","focusIn","focus","ownerDocument","elements","active","direction","startIndex","offset","total","next","nextIdx","props","__props","injectedTabContext","inject","tabContext","internalTabRef","onMounted","onUnmounted","isSelected","computed","handleFocus","handleSelection","handleMouseDown","event","getFocusDirection","arrowKeyCode","documentDir","forward","keycodes","handleKeyDown","list","tab","tabProps","variant","emit","__emit","selectedId","tabs","panels","tabGroupContext","id","idx","panel","provide","accessibleLabel"],"mappings":"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"}