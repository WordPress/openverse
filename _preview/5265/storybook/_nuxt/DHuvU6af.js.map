{"version":3,"file":"DHuvU6af.js","sources":["../../shared/types/item-group.ts","../../src/components/VItemGroup/VItemGroup.vue","../../src/components/VItemGroup/VItem.vue"],"sourcesContent":["import type { InjectionKey, Ref } from \"vue\"\n\nexport const itemGroupDirections = [\n  \"vertical\",\n  \"horizontal\",\n  \"columns\",\n] as const\nexport type ItemGroupDirection = (typeof itemGroupDirections)[number]\n\nexport const itemGroupTypes = [\"list\", \"menu\", \"radiogroup\"] as const\nexport type ItemGroupType = (typeof itemGroupTypes)[number]\n\nexport const itemGroupSizes = [\"small\", \"medium\"] as const\nexport type ItemGroupSize = (typeof itemGroupSizes)[number]\n\nexport type VIemGroupContext = {\n  direction: ItemGroupDirection\n  bordered: boolean\n  type: ItemGroupType\n  size: ItemGroupSize\n  showCheck: boolean\n}\n\nexport const VItemGroupContextKey = Symbol(\n  \"VItemGroupContext\"\n) as InjectionKey<VIemGroupContext>\n\nexport type VIemGroupFocusContext = {\n  isGroupFocused: Readonly<Ref<boolean>>\n  onItemKeyPress: (event: KeyboardEvent) => void\n  selectedCount: Readonly<Ref<number>>\n  setSelected: (selected: boolean, previousSelected: boolean) => void\n}\n\nexport const VItemGroupFocusContextKey = Symbol(\n  \"VItemGroupFocusContext\"\n) as InjectionKey<VIemGroupFocusContext>\n","<script setup lang=\"ts\">\nimport { useNuxtApp } from \"#imports\"\nimport { provide, ref, readonly } from \"vue\"\n\nimport { keycodes } from \"#shared/constants/key-codes\"\nimport type {\n  ItemGroupDirection,\n  ItemGroupSize,\n  ItemGroupType,\n} from \"#shared/types/item-group\"\nimport {\n  VItemGroupContextKey,\n  VItemGroupFocusContextKey,\n} from \"#shared/types/item-group\"\nimport { ensureFocus } from \"~/utils/reakit-utils/focus\"\n\nconst arrows = [\n  keycodes.ArrowUp,\n  keycodes.ArrowDown,\n  keycodes.ArrowLeft,\n  keycodes.ArrowRight,\n]\n\nconst props = withDefaults(\n  defineProps<{\n    /**\n     * The direction to render the items in.\n     *\n     * @default 'vertical'\n     */\n    direction?: ItemGroupDirection\n    /**\n     * Whether to render a bordered, separated list of items. When false each\n     * item will have whitespace separating them instead of borders.\n     *\n     * @default true\n     */\n    bordered?: boolean\n    /**\n     * The type of item group and item to render. This directly affects the `role` attribute\n     * of the container and the items themselves.\n     *\n     * `menu` should be used when providing a menu of independent options.\n     *\n     * @see https://www.w3.org/TR/wai-aria-1.1/#menu\n     *\n     * `radiogroup` should be used when providing a menu of options where only one can be selected at a time.\n     *\n     * @see https://www.w3.org/TR/wai-aria-1.1/#radiogroup\n     */\n    type?: ItemGroupType\n    /**\n     * Size of the item group corresponds to the size of the component.\n     */\n    size?: ItemGroupSize\n    /**\n     * Whether to show a checkmark when an item is selected.\n     */\n    showCheck?: boolean\n  }>(),\n  {\n    direction: \"vertical\",\n    bordered: true,\n    type: \"menu\",\n    size: \"small\",\n    showCheck: true,\n  }\n)\n\nconst nodeRef = ref<HTMLElement | null>(null)\nconst isFocused = ref(false)\nprovide(VItemGroupContextKey, props)\n\nconst i18n = useNuxtApp().$i18n\n\n/**\n * When the item group is horizontal, we need to \"reverse\" the behavior of the left and right arrow keys for RTL locales\n * because the DOM order gets reversed to be opposite the visual order relative to left/right movement.\n *\n * For vertical locales it should remain the same.\n * @param ltr\n * @param rtl\n */\nconst resolveArrow = (ltr: string, rtl: string) => {\n  return i18n.localeProperties.value.dir === \"rtl\" &&\n    props.direction === \"horizontal\"\n    ? rtl\n    : ltr\n}\n\nconst onItemKeyPress = (event: KeyboardEvent): undefined | number => {\n  if (!(arrows as string[]).includes(event.key) || !nodeRef.value) {\n    return\n  }\n\n  event.preventDefault()\n\n  const target = event.target\n\n  // While VItem ultimately renders a button at the moment, that could change in the future, so using a data attribute selector makes it more flexible for the future\n  const items = Array.from<HTMLElement>(\n    nodeRef.value?.querySelectorAll(\"[data-item-group-item]\")\n  )\n\n  const targetIndex = items.findIndex((item) => item === target)\n\n  switch (event.key) {\n    case keycodes.ArrowUp:\n    case resolveArrow(keycodes.ArrowLeft, keycodes.ArrowRight): {\n      if (targetIndex === 0) {\n        return ensureFocus(items[items.length - 1])\n      }\n      return ensureFocus(items[targetIndex - 1])\n    }\n    case keycodes.ArrowDown:\n    case resolveArrow(keycodes.ArrowRight, keycodes.ArrowLeft): {\n      if (targetIndex === items.length - 1) {\n        return ensureFocus(items[0])\n      }\n      return ensureFocus(items[targetIndex + 1])\n    }\n    default: {\n      return\n    }\n  }\n}\n\nconst selectedCount = ref(0)\n\n/**\n * @param selected\n * @param previousSelected\n */\nconst setSelected = (selected: boolean, previousSelected: boolean) => {\n  if (previousSelected && !selected) {\n    selectedCount.value -= 1\n  }\n  if (!previousSelected && selected) {\n    selectedCount.value += 1\n  }\n}\n\nconst focusContext = {\n  isGroupFocused: readonly(isFocused),\n  onItemKeyPress,\n  selectedCount: readonly(selectedCount),\n  setSelected,\n}\n\nprovide(VItemGroupFocusContextKey, focusContext)\n</script>\n\n<template>\n  <div\n    ref=\"nodeRef\"\n    class=\"flex w-full\"\n    :role=\"type\"\n    :class=\"{\n      'flex-col': direction === 'vertical',\n      'flex-row': direction !== 'vertical',\n      'flex-wrap': direction === 'columns',\n    }\"\n    @focusin=\"isFocused = true\"\n    @focusout=\"isFocused = false\"\n  >\n    <!--\n      @slot The items in the item group. Must include some `VItem`s but can\n      include additional elements as-needed.\n    -->\n    <slot name=\"default\" />\n  </div>\n</template>\n","<script setup lang=\"ts\">\nimport { inject, ref, computed, watch, useAttrs } from \"vue\"\n\nimport {\n  type VIemGroupContext,\n  type VIemGroupFocusContext,\n  VItemGroupContextKey,\n  VItemGroupFocusContextKey,\n} from \"#shared/types/item-group\"\nimport { VPopoverContentContextKey } from \"#shared/types/provides\"\nimport { warn } from \"~/utils/console\"\n\nimport VButton from \"~/components/VButton.vue\"\nimport VIcon from \"~/components/VIcon/VIcon.vue\"\n\ndefineOptions({ inheritAttrs: false })\n\nconst props = withDefaults(\n  defineProps<{\n    /**\n     * Whether the item is selected/checked.\n     */\n    selected: boolean\n    /**\n     * Whether the item is the first in the group.\n     */\n    isFirst: boolean\n    /**\n     * To change the underlying component for the VButton,\n     * pass `as` prop.\n     * @variants 'button', 'VLink'\n     */\n    as?: \"button\" | \"VLink\"\n  }>(),\n  {\n    as: \"button\",\n  }\n)\n\ndefineEmits<{ click: [] }>()\n\nconst attrs = useAttrs()\nconst injectedFocusContext = inject(VItemGroupFocusContextKey)\nconst isFocused = ref(false)\nconst isInPopover = inject(VPopoverContentContextKey, false)\nconst injectedContextProps = inject(VItemGroupContextKey)\n\nif (!injectedContextProps || !injectedFocusContext) {\n  throw new Error(\n    \"Do not use `VItem` outside of a `VItemGroup`. Use `VButton` instead.\"\n  )\n}\nconst contextProps = injectedContextProps as VIemGroupContext\nconst focusContext = injectedFocusContext as VIemGroupFocusContext\n\nif (isInPopover && contextProps.bordered) {\n  warn(\"Bordered popover items are not supported\")\n}\n\nif (attrs.size) {\n  warn(\"The `size` prop should be passed to the parent `VItemGroup` component.\")\n}\n\nwatch(\n  () => props.selected,\n  (selected, previousSelected) =>\n    focusContext.setSelected(selected, previousSelected)\n)\n\nconst tabIndex = computed(() => {\n  // If outside a radiogroup then everything can be tabbable in order\n  if (contextProps.type !== \"radiogroup\") {\n    return 0\n  }\n  // If no items are selected then all can be tabbable to ensure it is possible to enter into the group\n  if (\n    focusContext.selectedCount.value === 0 &&\n    props.isFirst &&\n    !focusContext.isGroupFocused.value\n  ) {\n    return 0\n  }\n  // If this one is focused then it should be the tabbable item\n  if (isFocused.value) {\n    return 0\n  }\n  // If the group is not focused but this is the selected item, then this should be the focusable item when focusing into the group\n  if (!focusContext.isGroupFocused.value && props.selected) {\n    return 0\n  }\n\n  // Otherwise, the item should not be tabbable. The logic above guarantees that at least one other item in the group will be tabbable.\n  return -1\n})\n\nconst splitAttrs = computed(() => {\n  const { class: classAttrs, ...rest } = attrs\n  return { class: classAttrs, vButtonAttrs: rest }\n})\n</script>\n\n<template>\n  <div\n    class=\"flex\"\n    :class=\"[\n      contextProps.direction,\n      splitAttrs.class,\n      {\n        [`${contextProps.direction}-bordered`]: contextProps.bordered,\n        [`${contextProps.direction}-popover-item`]: isInPopover,\n        'border border-overlay': contextProps.bordered,\n        'has-check': contextProps.showCheck,\n        'font-semibold': selected && !contextProps.showCheck,\n        'bg-transparent':\n          selected && contextProps.bordered && contextProps.showCheck,\n      },\n      isInPopover ? 'px-2' : '',\n    ]\"\n  >\n    <VButton\n      data-item-group-item\n      :as=\"as\"\n      class=\"relative min-w-full justify-between border-0 hover:bg-transparent-hover focus-visible:z-10\"\n      :class=\"{\n        'w-max': contextProps.direction === 'horizontal',\n        '!p-3': contextProps.size === 'small',\n        '!p-5 !ps-6': contextProps.size === 'medium',\n        'bg-transparent-hover ring-offset-gray-2':\n          selected && contextProps.showCheck,\n        'text-default': as === 'VLink',\n        '!px-2': !contextProps.showCheck,\n      }\"\n      variant=\"transparent-tx\"\n      size=\"disabled\"\n      :pressed=\"selected\"\n      :role=\"contextProps.type === 'radiogroup' ? 'radio' : 'menuitemcheckbox'\"\n      :aria-checked=\"selected\"\n      :tabindex=\"tabIndex\"\n      v-bind=\"splitAttrs.vButtonAttrs\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n      @keydown=\"focusContext.onItemKeyPress\"\n      @click=\"$emit('click')\"\n    >\n      <div\n        class=\"flex w-full flex-grow gap-x-2 whitespace-nowrap rounded-sm\"\n        :class=\"[`${contextProps.direction}-content`]\"\n      >\n        <slot name=\"default\" />\n      </div>\n      <VIcon\n        v-if=\"\n          selected &&\n          contextProps.direction === 'vertical' &&\n          contextProps.showCheck\n        \"\n        class=\"absolute\"\n        :class=\"contextProps.size === 'small' ? 'end-3' : 'end-5'\"\n        name=\"item-indicator\"\n      />\n    </VButton>\n  </div>\n</template>\n\n<style scoped>\n.vertical {\n  @apply min-w-max;\n}\n\n.vertical-bordered {\n  @apply border-b border-t-0;\n}\n\n.vertical:first-of-type {\n  @apply rounded-se-sm rounded-ss-sm;\n}\n\n.vertical-bordered:first-of-type {\n  @apply border-t;\n}\n\n.vertical:last-of-type {\n  @apply rounded-ee-sm rounded-es-sm;\n}\n\n.vertical-content {\n  @apply flex flex-row items-center;\n}\n\n.vertical-popover-item {\n  @apply pb-0;\n}\n\n.horizontal-bordered {\n  @apply border-e border-s-0 border-default;\n}\n\n.horizontal:first-of-type {\n  @apply rounded-s-sm;\n}\n\n.horizontal-bordered:first-of-type {\n  @apply border-s;\n}\n\n.horizontal:last-of-type {\n  @apply rounded-e-sm;\n}\n\n.horizontal-content {\n  @apply flex flex-col items-center;\n}\n\n.horizontal-popover-item {\n  @apply pe-0;\n}\n\n.horizontal-popover-item:last-of-type {\n  @apply pe-2;\n}\n</style>\n"],"names":["itemGroupDirections","VItemGroupContextKey","VItemGroupFocusContextKey","arrows","keycodes","props","__props","nodeRef","ref","isFocused","provide","i18n","useNuxtApp","resolveArrow","ltr","rtl","onItemKeyPress","event","target","items","_a","targetIndex","item","ensureFocus","selectedCount","setSelected","selected","previousSelected","focusContext","readonly","attrs","useAttrs","injectedFocusContext","inject","isInPopover","VPopoverContentContextKey","injectedContextProps","contextProps","warn","watch","tabIndex","computed","splitAttrs","classAttrs","rest"],"mappings":"0vBAEO,MAAMA,GAAsB,CACjC,WACA,aACA,SACF,EAiBaC,EAAuB,OAClC,mBACF,EASaC,EAA4B,OACvC,wBACF,0MCpBA,MAAMC,EAAS,CACbC,EAAS,QACTA,EAAS,UACTA,EAAS,UACTA,EAAS,UACX,EAEMC,EAAQC,EA8CRC,EAAUC,EAAwB,IAAI,EACtCC,EAAYD,EAAI,EAAK,EAC3BE,EAAQT,EAAsBI,CAAK,EAE7B,MAAAM,EAAOC,IAAa,MAUpBC,EAAe,CAACC,EAAaC,IAC1BJ,EAAK,iBAAiB,MAAM,MAAQ,OACzCN,EAAM,YAAc,aAClBU,EACAD,EAGAE,EAAkBC,GAA6C,OAC/D,GAAA,CAAEd,EAAoB,SAASc,EAAM,GAAG,GAAK,CAACV,EAAQ,MACxD,OAGFU,EAAM,eAAe,EAErB,MAAMC,EAASD,EAAM,OAGfE,EAAQ,MAAM,MAClBC,EAAAb,EAAQ,QAAR,YAAAa,EAAe,iBAAiB,yBAClC,EAEMC,EAAcF,EAAM,UAAWG,GAASA,IAASJ,CAAM,EAE7D,OAAQD,EAAM,IAAK,CACjB,KAAKb,EAAS,QACd,KAAKS,EAAaT,EAAS,UAAWA,EAAS,UAAU,EACvD,OAAIiB,IAAgB,EACXE,EAAYJ,EAAMA,EAAM,OAAS,CAAC,CAAC,EAErCI,EAAYJ,EAAME,EAAc,CAAC,CAAC,EAE3C,KAAKjB,EAAS,UACd,KAAKS,EAAaT,EAAS,WAAYA,EAAS,SAAS,EACnD,OAAAiB,IAAgBF,EAAM,OAAS,EAC1BI,EAAYJ,EAAM,CAAC,CAAC,EAEtBI,EAAYJ,EAAME,EAAc,CAAC,CAAC,EAE3C,QACE,MACF,CAEJ,EAEMG,EAAgBhB,EAAI,CAAC,EAMrBiB,EAAc,CAACC,EAAmBC,IAA8B,CAChEA,GAAoB,CAACD,IACvBF,EAAc,OAAS,GAErB,CAACG,GAAoBD,IACvBF,EAAc,OAAS,EAE3B,EAEMI,EAAe,CACnB,eAAgBC,EAASpB,CAAS,EAClC,eAAAO,EACA,cAAea,EAASL,CAAa,EACrC,YAAAC,CACF,EAEA,OAAAf,EAAQR,EAA2B0B,CAAY;g6CCpI/C,MAAMvB,EAAQC,EAwBRwB,EAAQC,EAAS,EACjBC,EAAuBC,EAAO/B,CAAyB,EACvDO,EAAYD,EAAI,EAAK,EACrB0B,EAAcD,EAAOE,EAA2B,EAAK,EACrDC,EAAuBH,EAAOhC,CAAoB,EAEpD,GAAA,CAACmC,GAAwB,CAACJ,EAC5B,MAAM,IAAI,MACR,sEACF,EAEF,MAAMK,EAAeD,EACfR,EAAeI,EAEjBE,GAAeG,EAAa,UAC9BC,EAAK,0CAA0C,EAG7CR,EAAM,MACRQ,EAAK,wEAAwE,EAG/EC,EACE,IAAMlC,EAAM,SACZ,CAACqB,EAAUC,IACTC,EAAa,YAAYF,EAAUC,CAAgB,CACvD,EAEM,MAAAa,EAAWC,EAAS,IAEpBJ,EAAa,OAAS,cAKxBT,EAAa,cAAc,QAAU,GACrCvB,EAAM,SACN,CAACuB,EAAa,eAAe,OAK3BnB,EAAU,OAIV,CAACmB,EAAa,eAAe,OAASvB,EAAM,SACvC,EAIF,EACR,EAEKqC,EAAaD,EAAS,IAAM,CAChC,KAAM,CAAE,MAAOE,EAAY,GAAGC,CAAS,EAAAd,EACvC,MAAO,CAAE,MAAOa,EAAY,aAAcC,CAAK,CAAA,CAChD"}